/** @preserve @license @cc_on
 * ----------------------------------------------------------
 * needlework version 0.0.3
 * A fully automated multi-threading utility for JavaScript
 * Copyright (c) 2021 Henrik Olofsson
 * All Rights Reserved. MIT License
 * https://mit-license.org/
 * ----------------------------------------------------------
 */
!function(){"use strict";!function(){class e{constructor(){this.freeThreads=new Map,this.threadQueue=[],this.numberOfRunningThreads=0,this.maxThreads=1,this.currentID=-1,this.metaData=new Map}getNextID(){return++this.currentID}createInlineWorker(e){}executeWorker(e,...t){return new Promise(((r,n)=>{e.onmessage=e=>{r(e.data)},e.onerror=n,e.postMessage(t)}))}terminate(e){this.freeThreads.has(e.threadID)&&(this.freeThreads.get(e.threadID).forEach((e=>{e.terminate()})),this.freeThreads.delete(e.threadID))}next(){if(this.threadQueue.length){const e=this.threadQueue.splice(0,1)[0];this.runThread(e[1],...e[2]).then((t=>{e[0].resolve(t)})).catch((t=>{e[0].reject(t)}))}}async run(e,...t){this.metaData.has(e.threadID)||this.metaData.set(e.threadID,{pendingTasks:0,terminationTimeout:void 0});const r=this.metaData.get(e.threadID);r.terminationTimeout&&(clearTimeout(r.terminationTimeout),delete r.terminationTimeout),r.pendingTasks++;return n.runThread(e,...t)}async runThread(e,...t){let r,n;const s=new Promise(((e,t)=>{r=e,n=t}));if(this.freeThreads.has(e.threadID)||this.freeThreads.set(e.threadID,[]),this.numberOfRunningThreads===this.maxThreads)return this.threadQueue.push([{resolve:r,reject:n},e,[...t]]),s;const a=this.freeThreads.get(e.threadID);a.length||a.push(this.createInlineWorker(e));const i=a.splice(0,1)[0];return this.numberOfRunningThreads++,this.executeWorker(i,...t).then((t=>{const n=this.metaData.get(e.threadID);this.freeThreads.get(e.threadID).push(i),this.numberOfRunningThreads--,n.pendingTasks--,n.pendingTasks||(n.terminationTimeout=setTimeout((()=>{this.terminate(e)}),1e4)),this.next(),r(t)})).catch((t=>{this.freeThreads.get(e.threadID).push(i),this.numberOfRunningThreads--;const r=this.metaData.get(e.threadID);r.pendingTasks--,r.pendingTasks||(r.terminationTimeout=setTimeout((()=>{this.terminate(e)}),1e4)),this.next(),n(t)})),s}}class t extends e{constructor(...e){super(...e),this.maxThreads=navigator.hardwareConcurrency-1}createInlineWorker(e){const t=e.toString(),r=`\n        function execute(${t.substring(t.indexOf("(")+1,t.indexOf(")"))}) {\n            ${t.substring(t.indexOf("{")+1,t.lastIndexOf("}"))}\n        }\n            self.onmessage = async (params) => {\n                let result = execute(...params.data)\n                if(result instanceof Promise) {\n                    result = await result\n                }\n            postMessage(result)\n        }\n    `;return new Worker(URL.createObjectURL(new Blob([r],{type:"text/javascript"})))}}class r extends e{constructor(...e){super(...e),this.maxThreads=require("os").cpus().length-1,this.Worker=require("worker_threads").Worker}createInlineWorker(e){const t=e.toString(),r=`\n        const { workerData, parentPort } = require("worker_threads")\n        function execute(${t.substring(t.indexOf("(")+1,t.indexOf(")"))}) {\n            ${t.substring(t.indexOf("{")+1,t.lastIndexOf("}"))}\n        }\n        parentPort.on("message", async (params) => {\n            let result = execute(...params)\n            if(result instanceof Promise) {\n                result = await result\n            }\n            parentPort.postMessage(result)\n        })\n        `,n={},s=new this.Worker(r,{eval:!0});return s.on("message",((...e)=>n.onmessage(...e))),s.on("error",((...e)=>n.onerror(...e))),n.postMessage=(...e)=>s.postMessage(...e),n.terminate=()=>s.terminate(),n.worker=s,n}}let n;n="undefined"==typeof window?new r:new t,Function.prototype.runThread=function(...e){return this.threadID||(this.threadID=n.getNextID()),n.run(this,...e)},Function.prototype.terminateThreads=function(){n.terminate(this)}}()}();
